#+TITLE: Doom Emacs Config

this setup was taken from [[https://www.youtube.com/watch?v=SzA2YODtgK4&ab_channel=thoughtbot][this video]] and the [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][setup he uses]].

#+begin_src elisp
;; -*- lexical-binding: t; -*-
(load "~/.doom.d/machine-specific.el")
#+end_src


* emacs setup / utils

use =company-mode= everywhere

#+begin_src elisp
(use-package! company
  :defer 2
  :config
  (setq company-idle-delay 0.5)
  (company-mode-on))

;; DONT add regex search to the jump stack!
(evil-set-command-property 'evil-ex-search-next :jump nil)
(evil-set-command-property 'evil-ex-search-backward :jump nil)

(global-company-mode 1)
;; company mode setup

(setq company-minimum-prefix-length 1
      company-dabbrev-minimum-length 3
      company-dabbrev-ignore-case 'keep-prefix
      company-dabbrev-other-buffers t

      display-buffer-base-action '((display-buffer-reuse-window display-buffer-use-least-recent-window)))

(progn company-dabbrev-minimum-length)
;; I don't want tab to cycle
(map! :map company-active-map
      "<tab>" #'company-complete
      )

#+end_src

#+RESULTS:


#+begin_src elisp
;; -*- lexical-binding: t; -*-
(setq multi-term-program "/bin/zsh")
(setq-default explicit-shell-file-name "/bin/zsh")


(use-package! exec-path-from-shell
  :config
  (dolist (var '("JAVA_HOME"))
    (add-to-list 'exec-path-from-shell-variables var)))

;; what is this?!
(exec-path-from-shell-initialize)

(window-prev-buffers)

;; omg finding this was such a pain in the ass
;; I need to use the debugger better! Just one single good debug
;; was what finally got the issue. I could have done it like 3 hours ago
(setq multi-term-switch-after-close nil)
#+end_src

#+RESULTS:
: kev-list-packages

* UI preferences
** Theme

Theme and resize
#+begin_src elisp
;; finer grained font size control
(setq doom-font-increment 1)
(setq use-package-always-defer 't)
(setq use-package-compute-statistics 't)


;; theme shite


(setq doom-customize-theme-hook nil)
;; see https://www.ditig.com/256-colors-cheat-sheet for colors! should just do 256 tbh so
;; also, maybe can look at default doom themes for some guidance
(load-theme 'my-vibrant t)

;; is good, but it's annoying because you don't rely completely on your theme
;; but this must be set first since things rely on this I guess
(custom-set-faces!
  `(default :background ,(doom-color 'bg)))
#+end_src

#+RESULTS:
| doom--customize-themes-h-16 |
** Modeline

doom-modeline package for [[https://github.com/seagle0128/doom-modeline][dopeness]]
#+begin_src elisp
(use-package! doom-modeline
  :init (doom-modeline-mode 1)
  :config
  ;; this sets column in modeline!
  (column-number-mode 1)

  (setq doom-modeline-height 1)
  (setq doom-modeline-percent-position nil)

  (buffer-local-value 'mode-line-format (current-buffer))

;; got rid of lsp, major-mode, misc-info
  (doom-modeline-def-modeline 'main
    '(bar window-number matches buffer-info remote-host buffer-position word-count parrot selection-info)
    '(persp-name grip irc mu4e gnus debug repl minor-modes input-method indent-info process vcs)))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25147 28244 234007 0) :init (25147 28244 234002 0) :config (25147 28244 233990 0) :config-secs (0 0 215 0) :init-secs (0 0 1768 0) :use-package-secs (0 0 1774 0)))

and make multi-term use it

#+begin_src elisp
(add-hook! term-mode-hook
           'doom-modeline-mode)
#+end_src
* My Plugins

** gpt
#+begin_src elisp


(defun surrounding-fn-bounds ()
  (cond
   ((eq major-mode 'clojure-mode) (cider-defun-at-point 'bounds))
   ((eq major-mode 'emacs-lisp-mode) (let (beg end)
                                       (save-excursion
                                         (end-of-defun)
                                         (beginning-of-defun)
                                         (setq beg (point))
                                         (end-of-defun)
                                         (setq end (point)))
                                       (list beg end)))
   ('t nil)))


(defun other-window ()
  "gets the window that is not the current one"
  (car (seq-filter (lambda (w) (not (eq (get-buffer-window) w)))
                   (window-list))))

;; TODO make this read from env var.
(defvar openai-api-key-1 "***")

(defun double-escape-string (s)
  (thread-last s
               (s-replace "\"" "\\\"")
               (s-replace "\n" "\\n")))

(defun atom-replace (old new tree)
  (if (atom tree)
      (if (eq old tree)
          new
        tree)
    (cons (atom-replace old new (car tree)) (atom-replace old new (cdr tree)))))

(defmacro thread$ (head &rest forms)
  (if (car forms)
      `(athread ,(atom-replace '$ head (car forms)) ,@(cdr forms))
    head))

(defun read-resp-buffer (b)
  (with-current-buffer b
    (goto-char (point-min))
    (re-search-forward "^$")
    (thread$ (json-read)
             (alist-get 'choices $)
             (aref $ 0)
             (alist-get 'text $))))

(defvar test-resp)

(cl-defun make-openai-request (&key url data handle)
  "makes an http request to the openai edit api to the davinci code model and passes
in `input' to get back edits made by the model"
  (let* ((url-request-method "POST")
         (url-request-data data)
         (url-request-extra-headers
          `(("Content-Type" . "application/json")
            ("Authorization" . ,(concat "Bearer " openai-api-key-1))))
         (_ (message (format "calling: %s with data: %s" url data)))
         (resp (url-retrieve-synchronously url)))
    (setq test-resp resp)
    (funcall handle resp)))


;; (progn test-resp)
;; (with-current-buffer test-resp
;;   (buffer-string))

;; (read-resp-buffer test-resp)

(defun code-davinci-edit-data (input)
  `(:url "https://api.openai.com/v1/edits"
    ;     "http://localhost:8000"
    :data
    ,(json-encode
      `((model . "code-davinci-edit-001")
        (input . ,input)
        (instruction .
         "Add code to the body of the function so it completes the documented task as simply as possible")
        (temperature . 0)
        (top_p . 1)))
    :handle ,(lambda (resp) (read-resp-buffer resp))))

(defun code-davinci-insert-data (input &optional separator)
  (unless separator
    (setq separator "\\[insert\\]"))
  (cl-destructuring-bind (pre post) (s-split separator input)
    (unless (and pre post)
      (throw 'input-error (format "need separater '%s'" separator)))
    `(:url "https://api.openai.com/v1/completions"
      :data
      ,(json-encode
        `((model . "code-davinci-002")
          (prompt . ,pre)
          (suffix . ,post)
          (temperature . 0)
          (max_tokens . 512)
          (top_p . 1)
          (frequency_penalty . 0.3)
          (presence_penalty . 0)))
      :handle (lambda (resp)
                (let ((insert (read-resp-buffer resp)))
                  (concat ,pre insert ,post))))))

(defun test-region (start end)
  (interactive "r")
  (print
   (list start end (buffer-substring-no-properties start end))))

(defun gpt-edit-2 ()
  (interactive)
  (let ((bounds (if (region-active-p)
                    (list (region-beginning) (region-end))
                  (surrounding-fn-bounds))))
    (unless bounds
      (message "unable to get fn bounds. Language not supported?"))
    (when bounds
      (replace-region-contents
       (car bounds)
       (cadr bounds)
       (lambda ()
         (thread$ bounds
                  (apply 'buffer-substring-no-properties $)
                  (code-davinci-insert-data $)
                  (apply 'make-openai-request $)))))))

#+end_src
** kevin paredit!

#+begin_src elisp
(define-minor-mode kevin-paredit-mode
  "lisp state for paredit"
  :lighter " kevin paredit"
  (setq evil-move-beyond-eol kevin-paredit-mode))

(defmacro kevin/sp-kill-movement-fn (name &rest body)
  `(defalias (intern (concat "kevin/kill-to-"
                             (symbol-name (quote ,name))))
     (lambda ()
       (interactive)
       (let ((p (point)))
         ,@body
         (sp-kill-region p (point))))))

(evil-define-minor-mode-key
  '(normal visual) 'kevin-paredit-mode
  "B" 'sp-backward-barf-sexp
  "b" 'sp-forward-barf-sexp
  "s" 'sp-forward-slurp-sexp
  "S" 'sp-backward-slurp-sexp
  "t" 'sp-transpose-sexp
  "f" (lambda ()
        (interactive)
        (print (list "use region" (use-region-p)))
        (if (use-region-p)
            (let ((m (mark))
                  (s (region-beginning)))
              (clojure-align (region-beginning) (region-end))
              (lsp-format-region (region-beginning) (region-end))
              ;; (print (list "region:" (region-beginning) (region-end)
              ;;              (region-active-p)))
              )
          (progn
            (sp-mark-sexp)
            (clojure-align (region-beginning) (region-end))
            (lsp-format-region (region-beginning) (region-end))
            (pop-mark))))
  ;; parens
  "[" 'sp-wrap-square
  "{" 'sp-wrap-curly
  "w" 'sp-wrap-round
  "W" 'sp-unwrap-sexp
  "m" 'sp-mark-sexp

  ;; killing
  "da" 'sp-splice-sexp-killing-around
  "d$" (kevin/sp-kill-movement-fn
        end-of-sexp
        (sp-end-of-sexp))
  "d0" (kevin/sp-kill-movement-fn
        beginning-of-sexp
        (sp-beginning-of-sexp))
  "dl" (kevin/sp-kill-movement-fn
        next-sexp
        (sp-forward-sexp))
  "dh" (kevin/sp-kill-movement-fn
        beginning-of-sexp
        (sp-backward-sexp))

  ;; movement
  "h" 'sp-backward-sexp
  "H" 'sp-backward-down-sexp
  "l" 'sp-forward-sexp
  "L" 'sp-down-sexp
  "j" 'sp-down-sexp
  "k" 'sp-backward-up-sexp
  "." 'kevin-paredit-mode
  (kbd "<escape>") 'kevin-paredit-mode)

(general-define-key
 :states '(normal visual)
 :keymaps 'global
 :prefix "SPC"
 "k" 'kevin-paredit-mode)
#+end_src

#+RESULTS:

* General Setup
** utility functions
#+begin_src elisp
(defmacro kev-setq-local (&rest kvs)
  `(progn
     ,@(mapcar
        (lambda (pair)
          (cl-destructuring-bind (sym val) pair
            `(progn
               (make-local-variable ',sym)
               (setq ,sym ,val))))
        (seq-partition kvs 2))))

(defmacro kev-fn (arglist &rest body)
  (let ((fargsym (gensym "arg")))
    `(lambda (,fargsym)
       (cl-destructuring-bind ,arglist
           ,fargsym
         ,@body))))

;; just realized this isn't even needed because the builtin
;; browse at remote already handles this exact situation
(defun kev-get-commit (beg end)
  (interactive "r")
  (require 'browse-at-remote)
  (let* ((commit (string-trim (buffer-substring beg end))) ;; was using (current-kill 0), but annoying
         (url
          (browse-at-remote--commit-url commit)))
    (kill-new url)
    (message (concat "copied: " url))))

(defun kev-project-ignored-p (root)
  (or (doom-project-ignored-p root)
      (string-match-p "/node_modules/" root)
      (string-match-p "/.cache/" root)
      (string-match-p "/.gitlibs/" root)))

(setq projectile-ignored-project-function 'kev-project-ignored-p)

;; evil-beginning-of-line
;; newline-and-indent
;; evil-next-line
;; FIXME the problem is that the value of end-point is no longer valid because (indent-according-to-mode) changes the buffer!
(defun kev-indent (beg end)
  "indents highlighted."
  (interactive "r")
  (save-excursion
    (let ((end-line (line-number-at-pos (- end 1))))
      (goto-char beg)
      (indent-according-to-mode)
      ;; such as a way to do the last line, but never try to go past it
      (while (< (line-number-at-pos)
                end-line)
        (evil-next-line)
        (indent-according-to-mode)))))

(defun projectile-term ()
  "if terminal exists in project, switch to it. else, create at project root"
  (interactive)
  (let ((term-buf (seq-some (lambda (b)
                              (with-current-buffer b
                                (and (derived-mode-p 'vterm-mode) b)))
                            (projectile-project-buffers))))
    (if term-buf
        (switch-to-buffer term-buf)
      (progn
        ;; no need to open in root bc vterm here does that!
        ;;(find-file (projectile-project-root))
        (+vterm/here nil)))))

(defun get-displayed-buffer (pred)
  (seq-some (lambda (w) (with-current-buffer (window-buffer w)
                        (and (funcall pred)
                             (window-buffer w))))
          (window-list)))

(defun call-previous-term-cmd ()
  (interactive)
  (with-current-buffer (get-displayed-buffer (lambda () (eq 'term-mode major-mode)))
    (term-send-up)
    (term-send-return)))

;; just map everywhere
(map!
 (:prefix ("SPC j" . "kevin stuff")
          :nv  "i" 'kev-indent
          :nv "t" 'projectile-term
          :nv "pp" 'jet-to-clipboard
          :nv "pt" 'call-previous-term-cmd
          (:prefix ("e" . "edit")
                   :n "e" 'edit-env-file
                   :n "c" 'doom-edit-config
                   :n "t" '(lambda () (interactive) (find-file "~/dotfiles/tmp.org")))))

(add-hook! magit-mode
  (map!
   (:prefix ("SPC j" . "kevin stuff")
            :map magit-section-mode-map
            :nv "c" 'kev-get-commit)))


;; this is actually great http://clhs.lisp.se/Body/03_dd.htm
;; aslo the cl-defmacro definition has some of that info

;; requires a (require 'straight) call. so quote it for now

(defun kev-list-packages ()
  (interactive)
  (mapcar (kev-fn (build-time deps (&whole whole &key type package &allow-other-keys))
                  (print (list :pack package
                               :buildt build-time
                               :type type)))
          (hash-table-values straight--build-cache)))

;; stolen from borkdude: https://github.https://github.com/borkdude/prelude/blob/master/personal/init.el#L195om/borkdude/prelude/blob/master/personal/init.el#L195
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

#+RESULTS:
: copy-file-name-to-clipboard

** Keybindings
#+begin_src elisp
;; sets comma as spc m
(setq evil-snipe-override-evil-repeat-keys nil)
(setq doom-localleader-key ",")

;; vinegar
(define-key evil-normal-state-map (kbd "-") 'dired-jump)

;; for evil-escape package
;; so much better than key chord!!
(setq-default evil-escape-key-sequence "jj")
(setq-default evil-escape-delay 0.2)

#+end_src

** Random Config
#+begin_src elisp
(setq projectile-switch-project-action #'projectile-dired)

;; makes the above thing actially work
(setq counsel-projectile-switch-project-action (lambda (project)
                                                 (dired (projectile-project-root project))))

;; delete dired buffers when switching
(define-advice dired-find-file (:around (orig-fun &rest _) dired-find-file-advice)
  (let ((prev-buf (current-buffer)))
    (funcall-interactively orig-fun)
    (when (and (eq 'dired-mode (buffer-local-value 'major-mode prev-buf))
               ;; ONLY FOR dired buffer! Leave it if we go to a file?
               (eq 'dired-mode (buffer-local-value 'major-mode (current-buffer)))
               ;; make sure it's not currently displayed
               (not (seq-find (lambda (w)
                                (eq prev-buf
                                    (window-buffer w)))
                              (window-list)))
               (not (eq prev-buf (current-buffer))))
      (kill-buffer prev-buf))))

(define-advice dired-up-directory (:around (orig-fun &rest args) dired-up-advice)
  (let ((prev-buf (current-buffer)))
    (apply #'funcall-interactively orig-fun args)
    (when (and (eq 'dired-mode (buffer-local-value 'major-mode prev-buf))
               ;; make sure it's not currently displayed
               (not (seq-find (lambda (w)
                                (eq prev-buf
                                    (window-buffer w)))
                              (window-list)))
               (not (eq prev-buf (current-buffer))))
      (kill-buffer prev-buf))))




;; github yank line link
;; (setq browse-at-remote-remote-type-domains
;;       (cons '("github.dev.pages" . "github") browse-at-remote-remote-type-domains))
;; dont prompt on exit
(setq confirm-kill-emacs nil)
;; when exit insert mode exit
(setq evil-move-cursor-back t)

;; flycheck has horrible perf.. maybe?
(setq flycheck-check-syntax-automatically '(save idle-change))
(setq flycheck-disabled-checkers '(emacs-lisp-checkdoc))

#+end_src

#+RESULTS:
| emacs-lisp-checkdoc |

line numbers

#+begin_src elisp
;; so we *can* display line numbers, but need to disable it for various
;; modes we don't want by default
(setq display-line-numbers-type t)
(remove-hook! '(prog-mode-hook text-mode-hook conf-mode-hook)
  #'display-line-numbers-mode)
#+end_src
** perf fixes
#+begin_src elisp
(defmacro timed-cached-funcall (time fn)
  (let ((last-time (gensym "last-time"))
        (cached-val (gensym "cached-val"))
        (fn-args (gensym "fn-args")))
    `(let ((,last-time -100.0)
           (,cached-val nil))
       (lambda (&rest ,fn-args)
         (when (> (- (float-time) ,last-time) ,time)
           (setq ,last-time (float-time))
           (setq ,cached-val (apply (quote ,fn) ,fn-args)))
         ,cached-val))))

;; this IS necessary. fuckin shit is slow without it
;; (setq kevin-project-root "johnson")
;; (setq kevin-project-root-timer
;;       (run-with-idle-timer 1 t (lambda () (setq kevin-project-root (projectile-project-root)))))
(setq kev-cached-project-root (timed-cached-funcall 1.0 projectile-project-name))

(setq frame-title-format '((:eval
                            (funcall kev-cached-project-root))))

;; noticed bad perf here
(setq kev-cached-modeline-buffer-file-state
      (timed-cached-funcall 1.0 doom-modeline-update-buffer-file-state-icon))

(define-advice doom-modeline-update-buffer-file-state-icon
    (:around (orig-fun &rest _) doom-modeline-advice)
  (funcall kev-cached-modeline-buffer-file-state))
#+end_src

#+RESULTS:
: doom-modeline-update-buffer-file-state-icon@doom-modeline-advice

** Project management
*** git
#+begin_src elisp
(use-package! browse-at-remote
  :config
  (print (list "regexps: " browse-at-remote-remote-type-regexps))
  (add-to-list 'browse-at-remote-remote-type-regexps
               '(:host "github.dev.pages$" :type "github"))
  )
#+end_src

* Org Mode
** setup

eval thing

#+begin_src elisp
(after! org
  (define-key org-mode-map (kbd "C-c f") #'org-babel-execute-src-block)

;; Including =org-tempo= restores the =<s=-style easy-templates that were
;; deprecated in Org 9.2.
  (require 'org-tempo)

  ;; start everything folded
  (setq org-startup-folded 't)
;; code blocks font
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  )

(map! :mode org-mode
      :localleader
      "'"  #'org-edit-special
      "g b" #'org-mark-ring-goto)
#+end_src

#+RESULTS:


TODO archive

#+begin_src elisp
(defun kevin/org-archive-subtree
  (org-copy-subtree))
#+end_src`
** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src elisp
(use-package! org-bullets-mode
  :hook org-mode)
#+end_src

#+RESULTS:


Use syntax highlighting in source blocks while editing.

#+begin_src elisp
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src elisp
#+end_src

** org-roam
#+begin_src elisp
(setq org-roam-v2-ack t)

;; org roam to display in same window
(customize-set-variable
 'display-buffer-alist
 (append '(("\\*org-roam\\*" (display-buffer-same-window))
           ("\\*lsp-help\\*" (display-buffer-same-window)))
       display-buffer-alist))

;; define some keys everywhere
(map!
 (:prefix ("C-c n" . "Org Roam")
  "f" 'org-roam-node-find
  "d" 'org-roam-dailies-find-directory))

(use-package! org-roam
  :commands org-roam-node-find
  :bind (:map org-roam-mode-map ;; this isn't a thing now
         (("C-c n l" . org-roam)
          ("C-c n g" . org-roam-graph)
          ("C-c n r" . org-roam-buffer-refresh))
         :map org-mode-map
         (("C-c n i" . org-roam-node-insert)
          ("C-c n c" . org-id-get-create)
          ("C-c n r" . org-roam-buffer-toggle)
          ("C-c n s" . org-roam-db-sync)
          ("C-c n a" . org-roam-alias-add)
          ; already implemented above globally
          ;("C-c n f" . org-roam-node-find)
          ;("C-c n d" . org-roam-dailies-find-directory)
          ))
  :config
  (setq org-roam-dailies-directory "daily/")
  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  ;(setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))

  (org-roam-db-autosync-mode 1))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25478 22530 426227 0) :init (25478 22530 426157 0) :init-secs (0 0 11 0) :use-package-secs (0 0 89 0)))

* Language-Specific
#+begin_src elisp

;; terraform lsp doesn't do shit
;;
;; (add-hook! terraform-mode
;;            (lsp)
;;            (lsp-mode 1))
#+end_src

#+RESULTS:

** rust

#+begin_src elisp
(use-package! yasnippet
  :hook ((lsp-mode . yas-minor-mode)))

;; (rustic-cargo-current-test)

(add-hook! rustic-mode
  (lsp)
  (lsp-mode 1)
  (yas-minor-mode 1)
  (read-only-mode 0)
  :local
  (kev-setq-local
   lsp-rust-analyzer-display-lifetime-elision-hints-enable "always"
        lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t
        lsp-headerline-breadcrumb-enable nil
        lsp-ui-sideline-enable t
        lsp-ui-sideline-show-code-actions t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover t
        lsp-signature-auto-activate t
        lsp-signature-render-documentation t
        lsp-ui-doc-enable nil
        lsp-ui-doc-show-with-cursor nil
        lsp-ui-doc-position 'at-point

        lsp-completion-show-detail t
        lsp-completion-show-kind t
        rustic-default-test-arguments "--benches --tests --all-features --nocapture")

  ;; TODO make local to rust mode
  (map! :map lsp-command-map
        "t"  #'lsp-rust-analyzer-related-tests
        "dd" #'lsp-rust-analyzer-open-external-docs))
#+end_src

#+RESULTS:

** Lisp

goto for elisp

#+begin_src elisp
(map! :mode emacs-lisp-mode
      :localleader
      "gg" #'elisp-slime-nav-find-elisp-thing-at-point
      "gb" #'pop-tag-mark)
#+end_src

disable doc checkers

#+begin_src elisp
#+end_src
** Ruby
#+begin_src elisp
(map! :mode ruby-mode
      :localleader
      :prefix ("g". "goto")
      "g" #'robe-jump
      :prefix ("e" . "eval..")
      "b" #'ruby-send-buffer
      "d" #'ruby-send-definition
      "f" #'ruby-send-block
      "e" #'ruby-send-last-stmt
      "r" #'ruby-send-region)

(remove-hook 'robe-mode-hook 'ac-robe-setup)

(eval-after-load 'company
  '(push 'company-robe company-backends))
#+end_src

#+RESULTS:

** JavaScript n TypeScript

#+begin_src elisp
;; lsp uses typescript-language-server
;; with npm i -g typescript-language-server
(add-hook! typescript-mode
  (lsp)
  (lsp-mode 1)

  (setq typescript-indent-level 2))
#+end_src

#+RESULTS:

update: should really just use emacs' lsp-mode for this

#+begin_src elisp
(add-hook! js2-mode
           (lsp)
           (lsp-mode 1))

(map! :mode js2-mode
      :localleader
      (:prefix ("g" . "goto...")
      "g" 'js2-jump-to-definition
      "b" #'pop-tag-mark))

#+end_src

for skewer, like a repl type thing for js

#+begin_src elisp

(map! :mode skewer
      (:prefix (",e" . "skewer eval")
       "d" 'skewer-eval-defun))

#+end_src

#+RESULTS:

** python
#+begin_src elisp
(add-hook! python-mode
           (require 'lsp-pyright)
           (lsp)
           (lsp-mode 1))
#+end_src

#+RESULTS:

** Clojure

nice keybindings

#+begin_src elisp
(defvar kevin-clojure-playbook
  '("((requiring-resolve 'dev/reset))"
    "(do (require 'portal.api) (portal.api/open) (add-tap #'portal.api/submit))"
    "((requiring-resolve 'clojure.repl.deps/sync-deps) :aliases [:test :dev :local-dev])"
    "((requiring-resolve 'vlaaad.reveal/inspect) *1)"
    "(doseq [_ (range 20)] (prn (tap> nil)))"
    "((requiring-resolve 'vlaaad.reveal/tap-log) :close-difficulty :easy)"
    "((requiring-resolve 'pjstadig.humane-test-output/activate!))"
    "((requiring-resolve 'lambdaisland.classpath/update-classpath!) {:aliases [:test :dev :local-dev]})"
    "(tap> {:vlaaad.reveal/command '(defaction ::intern-as-x [x]
                                   #(intern 'user 'x x))})"
    "(set! *warn-on-reflection* true)"))

(defun kevin-clojure-playbook (&optional output-to-current-buffer)
  "evaluate something from the playbook (w/ cider)"
  (interactive "P")

  (let ((cmd (ivy-read "clj cmd: "
                       kevin-clojure-playbook
                       :history 'kevin-clojure-playbook)))
    (cider-interactive-eval cmd
                            nil
                            (cider-defun-at-point 'bounds)
                            (cider--nrepl-pr-request-map))))



(defun kev-format-form (beg end)
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (save-excursion
                   (let ((end (progn (end-of-defun)
                                     (point))))
                     (clojure-backward-logical-sexp)
                     (list (point) end)))))
  (save-excursion
    (clojure-align beg end)
    (lsp-format-region beg end)))

(add-hook! clojure-mode
  ;;(aggressive-indent-mode) this shit so slow :(
  (hs-minor-mode)

  (setq cider-comment-prefix "(comment\n"
        cider-comment-continued-prefix "  "
        indent-region-function nil
        cider-comment-postfix ")"

        clojure-toplevel-inside-comment-form t
        ;; code alignment
        clojure-align-forms-automatically t)


  (defun kev-format-buffer ()
    (interactive)
    (save-excursion
        (lsp-format-buffer)
        (clojure-align (point-min) (point-max))))

  (define-clojure-indent
    (into 1)
    (do-template 2)
    (sc.api/letsc 1)
    (macrolet '(1 ((:defn)) nil)))
  )

(define-advice aggressive-indent--indent-if-changed (:around (orig-fun buffer) aggressive-indent-advice)
  (when (not (with-current-buffer buffer
               (evil-insert-state-p)))
    (funcall orig-fun buffer)))

;; prettier indentation!
(define-advice cider-maybe-insert-multiline-comment
    (:around (orig-fun result comment-prefix continued-prefix comment-postfix) cider-comment-advice)
  (funcall orig-fun result comment-prefix continued-prefix comment-postfix)
  (save-excursion
    (let ((end (point)))
      (sp-backward-sexp)
      (kev-indent (point) end))))

(map! :mode clojure-mode
      :localleader
      "e." (lambda (&optional output-to-current-buffer)
             (interactive "P")
             (save-excursion
               (goto-char (- (cadr (cider-list-at-point 'bounds)) 1))
               (cider-eval-last-sexp output-to-current-buffer)))
      "ef" #'cider-eval-defun-at-point
      "ep" #'kevin-clojure-playbook
      "e;" (lambda (&rest output-to-current-buffer)
             (interactive "P")
             (save-excursion
               (goto-char (- (cadr (cider-list-at-point 'bounds)) 0))
               (cider-pprint-form-to-comment 'cider-last-sexp nil)))
      "et" (lambda (&optional output-to-current-buffer)
             "run toplevel as clojure test; return report"
             (interactive "P")
             (cider-interactive-eval (concat "(binding [clojure.test/*report-counters* (ref clojure.test/*initial-report-counters*)]"
                                             "(clojure.test/test-vars [\n"
                                             (cider-defun-at-point)
                                             "])"
                                             "@clojure.test/*report-counters*)")
                                     nil
                                     (cider-defun-at-point 'bounds)
                                     (cider--nrepl-pr-request-map)))
      "en" #'cider-eval-ns-form
      "="  #'kev-format-form
      "ip" #'(lambda () (interactive) (insert "clojure.pprint/pprint")))

(defun cider-jack-in-babashka ()
  "Start an babashka nREPL server for the current project and connect to it."
  (interactive)
  (let* ((default-directory (project-root (project-current t)))
         (process-filter (lambda (proc string)
                           "Run cider-connect once babashka nrepl server is ready."
                           (when (string-match "Started nREPL server at .+:\\([0-9]+\\)" string)
                             (cider-connect-clj (list :host "localhost"
                                                      :port (match-string 1 string)
                                                      :project-dir default-directory)))
                           ;; Default behavior: write to process buffer
                           (internal-default-process-filter proc string))))
    (set-process-filter
     (start-file-process "babashka" "*babashka*" "bb" "--nrepl-server" "0")
     process-filter)))
#+end_src

#+RESULTS:
: cider-jack-in-babashka

lsp utils

#+begin_src elisp
;; develop on clojure-lsp
;; "~/Documents/me/misc/clojure-lsp/clojure-lsp"
;; else just "clojure-lsp"
(setq lsp-clojure-custom-server-command nil)

(defun lsp-clojure-nrepl-connect ()
  "Connect to the running nrepl debug server of clojure-lsp."
  (interactive)
  (let ((info (lsp-clojure-server-info-raw)))
    (save-match-data
      (when-let (port (and (string-match "\"port\":\\([0-9]+\\)" info)
                           (match-string 1 info)))
        (cider-connect-clj `(:host "localhost"
                             :port ,port))))))
#+end_src

cider configs

#+begin_src elisp
;;(setq cider-comment-prefix "\n;; => ")
(setq kev-clojure-cli-param-hist '("-M:test:dev:local-dev"
                                   "-M:cljs"
                                   "-X:local-dev:cljs"
                                   "-M:local-dev:server:cljs # clj(s) projects "
                                   "-A:test:dev:local-dev -m nrepl.cmdline --middleware '[cider.nrepl/cider-middleware]' --interactive --color # no reveal for java8"
                                   ))


(put 'cider-custom-cljs-repl-init-form 'safe-local-variable 'identity)
(use-package! cider
  ;; for some reason, this works. But after! doesn't work.
  ;; neither does `:hook (clojure-mode . cider-mode)`. Both cause the doom module
  ;; config to be ignored. This doesn't though
  :after-call clojure-mode-hook
  :config
  (setq cider-comment-prefix "\n;; => "
        cider-repl-buffer-size-limit 100)


        ;; fix shadow to not auto-evaluate forms!
        ;; well, can adjust this. for now, keeping
        ;; BUT maybe it would be a good idea to actually
        ;; look at shadow.cljs.devtools.api/nrepl-select
        ;; (setcar
        ;;  (cdr (seq-find (lambda (e)
        ;;                 (eq 'shadow (car e)))
        ;;                 cider-cljs-repl-types))
;;         'cider-shadow-select-cljs-init-form)


  ;; this is to fix the cider jack in to by my own thing because they changed some
  ;; version and got rid of =cider-clojure-cli-parameters=
  (setq cider-jack-in-dependencies nil)
  (setq cider-jack-in-auto-inject-clojure nil)
  (setq cider-inject-dependencies-at-jack-in t)
)

  ;; NOTE: instead set cider-jack-in-cmd with .dir-locals.el !!!
  ;; see how ppl do it:
  ;; https://github.com/djblue/portal/blob/48bda9b9b59795802a18f301d982b1f41d0db3c6/.dir-locals.el#L1
  ;;

  ;; (define-advice cider-jack-in-params (:around (orig-fun project-type) jack-in-param-advice)
  ;;   (pcase project-type
  ;;     ('clojure-cli (ivy-read "clojure cli params: "
  ;;                             kev-clojure-cli-param-hist
  ;;                             :history 'kev-clojure-cli-param-hist))
  ;;     (_ (funcall orig-fun project-type))))
;; (define-advice cider-inject-jack-in-dependencies (:around (orig-fun global-opts params project-type &optional command)
;;                                                           inject-deps-advice)
;;   (pcase project-type
;;     ('clojure-cli params)
;;     (_ (funcall orig-fun global-opts params project-type command))))

;; cider window popup!
;;
;; use display-buffer-alist to fix what we do!
;; cider-repl-pop-to-buffer-on-connect is 'display-only
;; cider-repl-display-in-current-window
;; (cider-jack-in)
(setf (alist-get "\\*cider-repl.*" display-buffer-alist)
      '(display-buffer-use-least-recent-window))

(define-advice nrepl-start-server-process (:around (orig-fun directory cmd on-port-callback) nrepl-start-server-process-advice)
  ;; insert prefix because sdkman doesn't insert the environment in emacs automatically
  ;; idk how to set it for the current emacs shell. may not be possible
  ;; was: "source \"$HOME/.sdkman/bin/sdkman-init.sh\" && { echo \"no\n\" | sdk env || echo 'no .sdkman?' } && sdk c java && "
  (let ((cmd-prefix "source \"$HOME/.sdkman/bin/sdkman-init.sh\" && echo \"no\\n\" | sdk c java && "))
    (funcall orig-fun directory (concat cmd-prefix cmd) on-port-callback)))
#+end_src

#+RESULTS:
: nrepl-start-server-process@nrepl-start-server-process-advice

** lsp
for code alignment, look at [[https://github.com/clojure-emacs/clojure-mode#indentation-of-macro-forms][clojure mode docs]] and at [[https://docs.cider.mx/cider/indent_spec.html][cider docs]]

#+begin_src elisp

(add-hook! lsp
  (lsp-ui-mode 1)
  ;; I don't think these are required?
;; (evil-set-command-property 'evil-ex-search-next :jump nil)
;; (evil-set-command-property 'evil-ex-search-backward :jump nil)
  )

;; really disable cider eldoc
;; idk if this is actually needed anymore
;; (define-advice cider-eldoc-setup (:around (orig-fun) cider-eldoc-advice)
;;   nil)

;; (add-hook! lsp-mode
;;   (turn-on-better-jumper-mode))

(use-package! lsp-mode
  :hook ((clojure-mode . lsp)
         (clojurec-mode . lsp)
         (clojurescript-mode . lsp)
         (go-mode .lsp)
         (lsp-mode . lsp-enable-which-key-integration))
  :commands lsp
  :config
  ;; add going back
  (map! :map lsp-command-map
        "gb" #'xref-go-back
        "d" #'lsp-ui-doc-glance)
  ;; add paths to your local installation of project mgmt tools, like lein

  (lsp-diagnostics-mode 0)
  ;; disable modeline diagnostics
  ;; this takes a long time on a screen rerender. Plus I never use
  (setq lsp-modeline-diagnostics-enable nil
        ;; focus help window when it shows up
        help-window-select t

        ;; because lsp indent is incredibly annoying for clojure
        ;; TODO restrict to just clojure?
        indent-region-function nil

        ;; disable sideline thing
        lsp-clojure-custom-server-command '("zsh" "-c" "clojure-lsp") ; to locally test clojure-lsp
        lsp-file-watch-threshold 10000
        lsp-diagnostics-provider :auto
        gc-cons-threshold (* 100 1024 1024)
        read-prcess-output-max (* 1024 1024)
        ;; disable big obnoxious window at top
        ;; from https://www.youtube.com/watch?v=grL3DQyvneI&ab_channel=LondonClojurians
        cider-eldoc-display-for-symbol-at-point nil ;; disable cider eldoc
        cider-repl-display-help-banner nil      ;; disable help banner
        ;; no header see https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/

        lsp-ui-doc-enable nil
        lsp-ui-doc-position 'at-point
        lsp-headerline-breadcrumb-enable nil
        lsp-ui-sideline-enable nil
        lsp-ui-sideline-show-code-actions nil)

  ;; don't watch public dir either. alternatively move to /target bc that's the default
  (add-to-list 'lsp-file-watch-ignored-directories
               "[/\\\\]public\\'")
  ;; necessary for showing references without relative path
  (setq ivy-xref-use-file-path t)
  (setq xref-file-name-display 'project-relative)
  (setq xref-show-definitions-function #'xref-show-definitions-buffer-at-bottom)
  (after! xref
    (setq xref-show-definitions-function #'xref-show-definitions-buffer-at-bottom))

  (dolist (m '(clojure-mode
               clojurec-mode
               clojurescript-mode
               clojurex-mode))
    (add-to-list 'lsp-language-id-configuration `(,m . "clojure"))))

;; makes so aggressive indent won't go until you exit insert mode
(define-advice aggressive-indent--indent-if-changed (:around (orig-fun buffer) aggressive-indent-advice)
  (when (not (with-current-buffer buffer
               (evil-insert-state-p)))
    (funcall orig-fun buffer)))
#+end_src


#+RESULTS:
: aggressive-indent--indent-if-changed@aggressive-indent-advice

** go
#+begin_src elisp

(add-hook! go-mode-hook)
#+end_src
** cue

#+begin_src emacs-lisp
(defconst cue-keywords
  '("package" "import" "for" "in" "if" "let"))

(defconst cue-constants '("null" "true" "false"))

(defconst cue-types
  '("int" "float" "string" "bool" "bytes"))

(defvar cue--font-lock-keywords
  `(("//.*" . font-lock-comment-face)
    (,(regexp-opt cue-constants 'symbols) . font-lock-constant-face)
    (,(regexp-opt cue-keywords 'symbols) . font-lock-keyword-face)
    (,(regexp-opt cue-types 'symbols) . font-lock-type-face)))

;;;###autoload
(define-derived-mode cue-mode prog-mode "CUE"
  "Major mode for the CUE language."

  ;; Comments
  (setq-local comment-start "// ")
  (setq-local comment-end "")
  (setq-local comment-start-skip "//[[:space:]]*")

  (setq indent-tabs-mode t)

  (setq-local font-lock-defaults '(cue--font-lock-keywords)))

;;;###autoload
(add-to-list 'auto-mode-alist '("\\.cue\\'" . cue-mode))
#+end_src

* TODO
- [ ] projectile terminal (gets or creates terminal at root of current project)
- [ ] default popup windows
- [ ] lsp-mode & cider-mode competition?
  - company backend (lsp seems completely disabled for this?)
  - eldoc stuffs they definitely compete
- [ ] company mode backend for text completion?
- [ ] move machine-specific setup into separate file so they don't have to keep changing
- [ ] clojure errors go to popwin
- [ ] keybindings
  - terminal
  - eval-previously-evaled-test
- [ ] auto right align for maps and lets (like how aggressive indent works)
- [ ] popup for cider errors instead of other window
- [ ] archive todo
  - would also like a popup to ask where to put it?
  - this could have much overlapping functionality with add-to-list
    which allows you insert an org-roam link and add that link to a
    list somewhere and then you put whatever at that link
- [ ] clojure errors go to popwin, no focus?
- [X] advice for dired, select file, do delete all dired buffers so back buffer works
- [X] eval-test-around-point
- [X] modify autoindent to be smarter! maybe use clj-kondo?
- [X] paredit
- [X] fix eval to comment
- [X] doom modeline
- [X] eval sexp around point
